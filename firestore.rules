/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model where all user-generated data
 * is segregated into user-specific subcollections. This "data silo" approach ensures that a user can only ever
 * access their own information, providing strong security and privacy by default.
 *
 * Data Structure: The core data is organized under the `/users/{userId}` path. Each user's
 * `excelImports`, `recipients`, and `appointments` are stored in dedicated subcollections within their
 * user document tree. A global `/emailTemplates` collection is also present, which is publicly readable.
 *
 * Key Security Decisions:
 * - Strict Ownership: All collections under `/users/{userId}` are only accessible by the authenticated user
 *   whose UID matches the `{userId}` in the path. This prevents any user from accessing another user's data.
 * - No User Listing: The rules do not provide a path for `/users`, effectively preventing clients from
 *   listing all users in the database.
 * - Public Templates: The `/emailTemplates` collection is publicly readable to allow all clients to access
 *   them, but writes are disabled pending a schema update to include an ownership field. This is a secure default.
 * - Denormalization for Authorization: This ruleset primarily uses path-based security (structural segregation),
 *   which is highly performant. The path `/users/{userId}` itself provides the ownership context, eliminating
 *   the need for extra `get()` calls or denormalized `ownerId` fields on child documents.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     * @param userId The user ID to check against, typically from the path.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * For update/delete operations, checks for ownership AND that the document exists.
     * This prevents unauthorized writes to non-existent paths.
     * @param userId The user ID to check against, typically from the path.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // --------------------------------------------------------------------------------
    // User Data Subcollections
    // All data nested under a user's ID is owned exclusively by that user.
    // --------------------------------------------------------------------------------

    /**
     * @description Controls access to a user's Excel import records.
     * @path /users/{userId}/excelImports/{excelImportId}
     * @allow A signed-in user (auth.uid='user123') creating their own import record at `/users/user123/excelImports/importABC`. (create)
     * @deny A different user (auth.uid='user456') trying to read an import record at `/users/user123/excelImports/importABC`. (get)
     * @principle Restricts access to a user's own data tree, enforcing a strict "data silo" for each user.
     */
    match /users/{userId}/excelImports/{excelImportId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to a user's recipient data.
     * @path /users/{userId}/recipients/{recipientId}
     * @allow A signed-in user (auth.uid='user123') listing their own recipients at `/users/user123/recipients`. (list)
     * @deny An anonymous user trying to create a recipient record. (create)
     * @principle Restricts access to a user's own data tree, enforcing a strict "data silo" for each user.
     */
    match /users/{userId}/recipients/{recipientId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to a user's appointment data.
     * @path /users/{userId}/appointments/{appointmentId}
     * @allow A signed-in user (auth.uid='user123') updating their own appointment at `/users/user123/appointments/apptXYZ`. (update)
     * @deny A different user (auth.uid='user456') trying to delete an appointment at `/users/user123/appointments/apptXYZ`. (delete)
     * @principle Restricts access to a user's own data tree, enforcing a strict "data silo" for each user.
     */
    match /users/{userId}/appointments/{appointmentId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    // --------------------------------------------------------------------------------
    // Global Collections
    // --------------------------------------------------------------------------------

    /**
     * @description Controls access to the global collection of email templates.
     * @path /emailTemplates/{emailTemplateId}
     * @allow Any user, signed-in or anonymous, reading a template at `/emailTemplates/welcomeTemplate`. (get, list)
     * @deny Any user trying to create a new template. Writes are disabled until an ownership model is defined. (create)
     * @principle Allows public read access for shared resources, but locks down all write operations for security until a clear ownership schema (e.g., an `ownerId` field) is added to the documents.
     */
    match /emailTemplates/{emailTemplateId} {
      allow get: if true;
      allow list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'EmailTemplate' entity is missing an 'ownerId' or 'authorId' field.
      // Writes are disabled to prevent any user from modifying shared templates.
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }
}